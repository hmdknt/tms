= Java実装ガイドライン
:toc: left
:toclevel: 3
:toc-title: 目次
:figure-caption: 図
:table-caption: 表
:imagesdir: images
:homepage: https://traningmanagementsystem.github.io/devlog/

== ディレクトリ構成
プロジェクトのディレクトリ構成を以下に示します。

[source, text]
----
tms
 │
 ├─docs :ドキュメント
 │
 ├─frontend-api :フロントエンドREST-APIサーバー
 │
 ├─frontend-web :フロントエンドWEBサーバー
 │
 ├─mockup :モックアップ
 │
 ├─schema :データベーススキーマ
 │
 ├─swagger :OpenAPI(Swagger)
 │    │
 │    ├─frontend-api-server
 │    ├─frontend-api-client
----



== アーティファクト定義
Java資材は全てGrdleによるビルドを行います。 +
ライブラリの形式はMaven形式とします。 +
アーティファクトの定義は以下の通りとします。

[cols="40,60"]
|====

|グループ
|work.segarden.tms

|アーティファクト
|モジュール名 +
(ext) +
frontend-api +
frontend-api-client

|バージョン
|セマンティックバージョニングを採用します。 +
suffixは別途整理します。

|====

== モジュール定義


== 命名ルール

簡易的ではありますが、各種命名ルールを定めます。

=== パッケージ構成
各種パッケージの命名ルールは以下の通りとなります。

[source, text]
----
プロジェクト（frontend-api等）
 │
 ├─src/main/java
 │    │
 │    └─work.segarden.tms.<モジュール名>
 │        │
 │        ├─bean // <1>
 │        │  ├─model // <2>
 │        │  └─entity // <3>
 │        ├─configuration // <4>
 │        ├─control // <5>
 │        ├─mapper // <6>
 │        ├─service // <7>
 │        ├─type // <8>
 │        ├─helper // <9>
----

基本思想としてパッケージ名は名詞とします。 +

<1> JavaBeanを格納します。
<2> モデルクラスを格納します。
<3> エンティティ（データベースのテーブルと１対１）クラスを格納します。
<4> Javaコンフィグレーションクラスを格納します。
<5> アプリケーション層のクラスを格納します。コントローラ、デリゲートが格納されます。
<6> インフラストラクチャ層のマッパークラスを格納します。
<7> ドメイン層のサービスクラスを格納します。
<8> 定数定義Enumを格納します。
<9> ユーティリティクラスを格納します。

=== クラス名
各種クラス名の命名ルールは以下の通りとなります。

[cols="20,30,50"]
|====

|種別
|クラス
|ルール

|共通
|設定クラス
|*Configration.java

|共通
|Mapper（MyBatis）
|*Mapper.java

|共通
|エンティティ
|<テーブル物理名のキャメルケース>.java

|共通
|定数Enum
|*Type.java

|共通
|ユーティリティ
|*Helper.java

|共通
|例外
|*Exception.java

|オンライン
|コントローラ
|*Controller.java

|オンライン
|デリゲート
|*Delegate.java +
*DelegateImpl.java

|オンライン
|サービス
|*Service.java +
*ServiceImpl.java

|====

=== メッセージID
めんどくさいな。。。 +
正直どうでもいい。。。

== コーディング規約
https://www.future.co.jp[フューチャーアーキテクト株式会社] がまとめておられる
Javaのコーディング規約がとてもまとまっておりJDK8にも対応しているため、
こちらを参照することにします。

https://future-architect.github.io/coding-standards/documents/forJava/Java%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E8%A6%8F%E7%B4%84.html[Javaコーディング規約]

== 共通

=== MyBatisGeneratorによる自動生成

=== lombok

=== 定数Enum

=== ユーティリティ
ユーティリティクラスは、staticメソッドのみを保有するシングルトンクラスを作成するのではなく、
SpringのDIコンテナに管理を任せてインジェクションして利用するようなクラスを実装します。 +
 +
これは本開発でのポリシーであり、一般的にはstaticメソッドを保有するシングルトンユーティリティが数多く存在します。

=== トランザクション制御

== REST-API

=== アプリケーションの構成
本開発では、OpenAPI（Swagger）を利用したREST-APIの構築を行うため、
通常のSpringBoot・SpringMVCでREST-APIを実装するよりは少し冗長的なクラス構成となっています。
しかし、スクラッチ開発と比較し初期実装コストが低くなる他、仕様変更時の改修コストも低くなり生産性の向上が見込めます。

image::Sec540_Dev_Programming_restapi_applayer.png[]

アプリケーションの構成として、大きく以下の３つに分類する。 +

[cols="30,70"]
|====

|階層
|説明

|アプリケーション
|クライアントとリクエスト/レスポンスのやり取りを行う階層です。
コントローラがこの層のメイン処理となるが、処理内容としては入力チェック（単項目・相関）、ドメイン層への処理の移譲、例外ハンドリング、レスポンスの編集となります。
フレームワークや共通化によって実際に多くの実装担当者がスクラッチによって開発する部分は極小化されていることが多く望ましくもあります。

|ドメイン
|システムの実現したい仕様を実装する階層です。サービス（ビジネスロジック）がメイン処理となります。
リポジトリ等を利用してデータベースやキャッシュにアクセスしたり、APIクライアント等の部品を利用して外部のシステムと連動したりもします。
基本的にトランザクションデータを作り出したりするのはドメイン層に閉じておくことが望ましいと考えます。

|インフラストラクチャ
|主に永続化層とのアクセスを担います。ORM（ORMapper）等がこの実装に当たります。

|====


本開発では、OpenAPI（Swagger）を利用することによってアプリケーション層の実装をほぼ行わなくても良い状況となります。
また、インフラストラクチャ層の実装もMyBatisGeneratorを利用することによって複雑性の低いデータベースアクセス処理は
ソースコードの自動生成を行なったソースをそのまま利用することができます。


=== 実装の流れ
REST-APIはOpenAPI（Swagger）を利用して製造を行うため、製造のフローがスクラッチとは異なります。
以下のような流れで実装を進めてください。

image::Sec540_Dev_Programming_restapi_workflow.png[]

==== ソースコード出力
Swaggerによる自動生成方法は
プロジェクト直下で以下のコマンドを実行することで自動生成を行うことができます。

[source,bash]
----
gradle generateSwaggerCode
----

プロジェクトはブランク状態で既にライブラリの依存関係が設定されているため
特に何も行う必要がなくクラス参照を行うことができる。

==== デリゲートの実装
デリゲートはコントローラと同一のパッケージに出力される。

ちょっと投げやりに書きます。 +
現状実装されているサンプルを見ればわかると思いますので、まずはそちらを参照。
このクラスはDIコンテナに登録してインジェクションして利用したいので「@Component」は絶対に必要です。
また、サービスクラスはこのクラスから利用するので、必DIコンテナ経由で取得したものを利用してください。
コンストラクタインジェクションの方が最近っぽいですが、どちらでも構いません。

==== サービスの実装
普通に、ビジネスロジック、トランザクション処理を実装して行ってください。
@Transactionalとかまぁ適当にググればなんとかなります。
　


=== セッション管理
SpringSessionを利用する。 +
キャッシュサーバー（Redis）を利用。